<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-title" content="ColorRant">
    <title>ColorRant Pro: Final</title>
    <style>
        :root { --bg: #1e1e1e; --panel: #2d2d2d; --text: #f0f0f0; --accent: #ff9f43; --canvas-ui: #0984e3; --danger: #ff7675; }
        
        body { margin: 0; overflow: hidden; background: var(--bg); font-family: 'Segoe UI', sans-serif; color: var(--text); user-select: none; touch-action: none; }
        input { user-select: text !important; pointer-events: auto !important; }

        #viewport { position: relative; width: 100vw; height: 100vh; overflow: hidden; cursor: crosshair; background: #111; }
        
        #layer-container { 
            position: absolute; top: 0; left: 0; 
            transform-origin: 0 0; 
            background: #ffffff; 
            box-shadow: 0 0 60px rgba(0,0,0,0.5); 
            display: block; 
        }

        .layer-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        
        #sel-mask-canvas { display: none; }
        #ants-cache-canvas { display: none; }

        #overlay-canvas { 
            position: absolute; top: 0; left: 0; 
            width: 100%; height: 100%; 
            pointer-events: none; z-index: 100; 
        }

        body.grabbing { cursor: grabbing !important; }
        body.zooming { cursor: zoom-in !important; }
        
        #cursor { 
            position: absolute; pointer-events: none; 
            border: 1px solid #fff; border-radius: 50%; 
            transform: translate(-50%, -50%); z-index: 200; 
            mix-blend-mode: exclusion; pointer-events: none; 
            box-shadow: 0 0 2px rgba(0,0,0,0.5);
        }
        body.grabbing #cursor, body.zooming #cursor { opacity: 0; }

        .panel {
            position: absolute; background: rgba(45, 45, 45, 0.95);
            backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
            padding: 10px; border-radius: 12px; border: 1px solid #444;
            display: flex; flex-direction: column; gap: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.4); pointer-events: auto; z-index: 200;
        }

        .top-bar { top: 15px; left: 15px; right: 15px; flex-direction: row; justify-content: space-between; align-items: center; width: auto; }
        .tools-panel { top: 80px; left: 15px; width: 240px; }
        .layers-panel { top: 80px; right: 15px; width: 200px; }

        .btn-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 6px; }
        .btn-grid-3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 6px; }
        .tool-group { display: flex; gap: 4px; background: #1a1a1a; padding: 4px; border-radius: 8px; }
        
        .btn, .t-btn { 
            background: #3a3a3a; color: #ccc; border: 1px solid #444; 
            padding: 10px 4px; font-size: 11px; font-weight: bold; 
            text-align: center; border-radius: 6px; cursor: pointer; transition: 0.1s; 
        }
        .btn:hover, .t-btn:hover { background: #4a4a4a; }
        
        .t-btn.active { background: #eee; color: #111; } 
        .t-btn.active-blue { background: #0984e3; color: white; } 
        .t-btn.active-purp { background: #9b59b6; color: white; } 
        .t-btn.active-green { background: #00b894; color: white; } 
        .t-btn.active-mix { background: var(--mixer); color: #000; } 
        .t-btn.active-move { background: #e84393; color: white; } 
        
        .btn.active-brush { background: #eee; color: #111; border-color: white; transform: scale(1.05); }
        .btn.active-opt { background: #0984e3; color: white; border-color: white; }

        input[type="color"].active-stop { border: 2px solid #fff; box-shadow: 0 0 5px rgba(255,255,255,0.5); }

        .row { display: flex; justify-content: space-between; font-size: 11px; color: #888; font-weight: 700; margin-bottom: 2px; text-transform: uppercase; }
        input[type="range"] { width: 100%; accent-color: var(--accent); margin: 8px 0; cursor: pointer; }
        input[type="number"] { background: #111; border: 1px solid #444; color: white; width: 50px; padding: 4px; border-radius: 4px; }

        .layer-list { height: 180px; overflow-y: auto; background: #111; border: 1px solid #333; padding: 4px; border-radius: 6px; display: flex; flex-direction: column-reverse; gap: 2px; }
        .l-item { padding: 8px; background: #222; font-size: 12px; display: flex; justify-content: space-between; border-radius: 4px; cursor: pointer; border: 1px solid transparent; }
        .l-item.active { background: #333; border-color: #666; border-left: 3px solid var(--accent); color: white; }
        .l-vis { width: 10px; height: 10px; background: #444; border-radius: 50%; }
        .l-vis.on { background: var(--accent); }

        #sample-feedback { position: absolute; width: 50px; height: 50px; border: 3px solid #ffd700; border-radius: 50%; transform: translate(-50%,-50%) scale(0); transition: transform 0.2s; pointer-events: none; z-index: 300; }
        #sample-feedback.active { transform: translate(-50%,-50%) scale(1); }
    </style>
</head>
<body oncontextmenu="return false;">

<div id="viewport">
    <div id="layer-container">
        <canvas id="sel-mask-canvas"></canvas>
        <canvas id="ants-cache-canvas"></canvas>
        <canvas id="overlay-canvas"></canvas>
    </div>
    <div id="sample-feedback"></div>

    <div class="panel top-bar">
        <div style="font-weight:900; letter-spacing:1px; color:white;">ColorRant</div>
        <div class="tool-group">
            <div id="t-brush" class="t-btn active" onclick="setTool('brush')">BRUSH</div>
            <div id="t-mixer" class="t-btn" onclick="setTool('mixer')">MIX</div>
            <div id="t-blend" class="t-btn" onclick="setTool('blend')">BLEND</div>
            <div id="t-lasso" class="t-btn" onclick="setTool('lasso')">SEL</div>
            <div id="t-transform" class="t-btn" onclick="setTool('transform')">MOVE</div>
            <div id="t-gradient" class="t-btn" onclick="setTool('gradient')">GRAD</div>
            <div id="t-eraser" class="t-btn" onclick="setTool('eraser')">ERS</div>
            <div id="t-canvas" class="t-btn" onclick="setTool('canvas')">CNV</div>
        </div>
        <div class="tool-group">
            <div class="t-btn" onclick="undo()" title="Ctrl+Z">↶</div>
            <div class="t-btn" onclick="redo()" title="Ctrl+Y">↷</div>
        </div>
    </div>

    <div class="panel tools-panel">
        <div class="rgb-box">
            <div id="rgbPreview" style="height:30px; background:#ff9f43; border-radius:4px; margin-bottom:5px;"></div>
            <div class="row" style="align-items:center"><span style="color:#ff4757">R</span><input type="range" id="sl-r" min="0" max="255" value="255"></div>
            <div class="row" style="align-items:center"><span style="color:#2ecc71">G</span><input type="range" id="sl-g" min="0" max="255" value="159"></div>
            <div class="row" style="align-items:center"><span style="color:#0984e3">B</span><input type="range" id="sl-b" min="0" max="255" value="67"></div>
        </div>

        <div id="brush-controls">
            <div class="row" style="margin-top:10px;">Brush Type</div>
            <div class="btn-grid" style="grid-template-columns:1fr 1fr 1fr;">
                <div id="b-block" class="btn" onclick="setBrush('block')">BLK</div>
                <div id="b-round" class="btn" onclick="setBrush('round')">RND</div>
                <div id="b-rake" class="btn active-brush" onclick="setBrush('rake')">RAKE</div>
                <div id="b-air_soft" class="btn" onclick="setBrush('air_soft')">SOFT</div>
                <div id="b-air_grain" class="btn" onclick="setBrush('air_grain')">GRAIN</div>
            </div>
            
            <div class="row" style="margin-top:10px;">Size: <span id="val-size">60</span></div>
            <input type="range" id="sl-size" min="2" max="300" value="60">
            
            <div class="row">Opacity: <span id="val-op">100</span>%</div>
            <input type="range" id="sl-op" min="1" max="100" value="100">
            
            <div class="row">Flow: <span id="val-mix">20</span>%</div>
            <input type="range" id="sl-mix" min="1" max="100" value="20">
            
            <div class="row">Jitter: <span id="val-jitter">0</span></div>
            <input type="range" id="sl-jitter" min="0" max="100" value="0">
            
            <div class="row">Texture/Grain: <span id="val-grain">20</span>%</div>
            <input type="range" id="sl-grain" min="0" max="100" value="20">

            <label style="font-size:11px; display:flex; align-items:center; gap:5px; margin-top:5px;">
                <input type="checkbox" id="pressureChk" checked onchange="state.usePressure=this.checked"> Pressure Sensitivity
            </label>
            <div id="mixer-hint" style="display:none; font-size:10px; color:#e1b12c; margin-top:5px; padding:4px; border:1px solid #e1b12c; background:rgba(225,177,44,0.1);">Mixer: Alt+Click to Sample Texture</div>
        </div>

        <div id="transform-controls" style="display:none;">
            <div class="row" style="color:#e84393; font-weight:900;">Transform Active</div>
            <div style="font-size:11px; color:#aaa; margin-top:5px;">Drag inside to move.<br>Drag corners to scale.<br>Hold SHIFT to constrain.<br>Press ENTER to Apply.</div>
            <div class="btn" style="margin-top:10px; background:#e84393; color:white;" onclick="commitTransform()">APPLY (ENTER)</div>
        </div>

        <div id="grad-controls" style="display:none;">
            <div class="row">Gradient Type</div>
            <select id="gradType" onchange="state.gradType=this.value" style="width:100%; margin-bottom:5px; background:#222; color:#fff; border:1px solid #444; padding:4px;">
                <option value="linear">Linear</option>
                <option value="radial">Radial</option>
            </select>
            <div class="row">Gradient Colors</div>
            <div style="display:flex; gap:5px; margin-bottom:10px;">
                <input type="color" id="gradStart" value="#ff9f43" onclick="setActiveGradStop('start')" style="width:100%; height:30px;">
                <input type="color" id="gradEnd" value="#2c3e50" onclick="decoupleGradient(); setActiveGradStop('end')" style="width:100%; height:30px;">
            </div>
            <div style="font-size:10px; color:#666; margin-bottom:5px;">Pick color applies to Start & End unless split.</div>
            <div class="row">Opacity Stops</div><input type="range" id="gradStartAlpha" min="0" max="100" value="100"><input type="range" id="gradEndAlpha" min="0" max="100" value="100">
        </div>

        <div id="lasso-controls" style="display:none;">
            <div class="row">Selection Shape</div>
            <div class="btn-grid">
                <div id="l-free" class="btn active-brush" onclick="setLassoShape('free')">FREE</div>
                <div id="l-poly" class="btn" onclick="setLassoShape('poly')">POLY</div>
                <div id="l-rect" class="btn" onclick="setLassoShape('rect')">RECT</div>
                <div id="l-circ" class="btn" onclick="setLassoShape('circ')">CIRC</div>
            </div>
            <div class="row" style="margin-top:10px;">Operation (Hold Alt for Sub)</div>
            <div class="btn-grid-3">
                <div id="op-new" class="btn active-opt" onclick="setLassoOp('new')">NEW</div>
                <div id="op-add" class="btn" onclick="setLassoOp('add')">ADD</div>
                <div id="op-sub" class="btn" onclick="setLassoOp('sub')">SUB</div>
            </div>
            <div class="btn" style="margin-top:10px; color:#ff7675" onclick="clearSelection()">DESELECT (D)</div>
        </div>

        <div id="canvas-controls" style="display:none;">
            <div class="row">Canvas Size (A4 Default)</div>
            <div style="display:flex; gap:5px; align-items:center; margin:10px 0;"><input type="number" id="cnv-w"> x <input type="number" id="cnv-h"><div class="btn" onclick="rotateCanvas()" style="padding:4px 8px;">↻</div></div>
            <div class="btn" style="background:var(--canvas-ui); color:white;" onclick="applyCanvasResize()">APPLY RESIZE</div>
        </div>

        <div class="btn" style="margin-top:15px; background:#0984e3; color:white;" onclick="saveImage()">SAVE IMAGE</div>
    </div>

    <div class="panel layers-panel">
        <div class="row">Layers</div>
        <div class="layer-list" id="layerList"></div>
        <div style="margin-top:8px; border-top:1px solid #333; padding-top:8px;">
            <div class="row">Opacity: <span id="val-layer-op">100</span>%</div>
            <input type="range" id="layerOpacity" min="0" max="100" value="100">
            <div class="row" style="align-items:center; margin-top: 10px;">Mode <select id="blendModeSel" onchange="setLayerProp('blendMode', this.value)" style="width:80px;"><option value="normal">Normal</option><option value="multiply">Multiply</option><option value="screen">Screen</option><option value="overlay">Overlay</option></select></div>
            <label style="font-size:11px; display:flex; align-items:center; gap:5px; margin-top:5px;"><input type="checkbox" id="alphaLockChk" onchange="setLayerProp('alphaLock', this.checked)"> Alpha Lock</label>
            <label style="font-size:11px; display:flex; align-items:center; gap:5px; margin-top:5px;"><input type="checkbox" id="clipMaskChk" onchange="setLayerProp('clipped', this.checked)"> Clip Mask</label>
        </div>
        <div class="btn-grid" style="margin-top:10px;">
            <div class="btn" onclick="addLayer()">NEW</div>
            <div class="btn" style="color:#ff7675" onclick="deleteLayer()">DEL</div>
            <div class="btn" onclick="clearLayer()">CLEAR</div>
        </div>
    </div>
</div>

<div id="cursor"></div>

<script>
    const CONFIG = { w: 1240, h: 1754 };
    const state = {
        tool: 'brush', brush: 'rake', color: '#ff9f43', size: 60, opacity: 1.0, mix: 0.20, jitter: 0, grain: 0.2,
        isDrawing: false, canBlend: false, isSampling: false, mixerBuffer: null,
        lassoPoly: [], lassoMode: 'free', lassoOp: 'new', hasSelection: false,
        activeSelectionPath: null,
        gradStartColor: '#ff9f43', gradEndColor: '#2c3e50', gradStartOpacity: 1.0, gradEndOpacity: 1.0, gradType: 'linear', gradDecoupled: false, activeGradStop: 'start',
        gradDragStart: null, gradDragCurrent: null, pressure: 1.0, usePressure: true,
        lassoStartPoint: null, lassoEndPoint: null,
        transformImg: null, transformRect: null, transformHandle: null, selectionBounds: null
    };

    const view = { x: 0, y: 0, scale: 0.5 };
    let isSpace = false, isZ = false, dragStart = null;
    let layers = [], activeIdx = 0, layerCounter = 0;
    let historyStack = [], redoStack = [];
    let bristles = [], brushLoad = {r:0, g:0, b:0}; const BRISTLE_COUNT = 20;
    
    // References
    const container = document.getElementById('layer-container');
    const overlayCanvas = document.getElementById('overlay-canvas');
    const overlayCtx = overlayCanvas.getContext('2d');
    const selCanvas = document.getElementById('sel-mask-canvas');
    const selCtx = selCanvas.getContext('2d');
    const antsCanvas = document.getElementById('ants-cache-canvas');
    const antsCtx = antsCanvas.getContext('2d');
    const cursor = document.getElementById('cursor');
    const scratchCanvas = document.createElement('canvas');
    const scratchCtx = scratchCanvas.getContext('2d');

    window.onload = () => {
        document.getElementById('cnv-w').value = CONFIG.w;
        document.getElementById('cnv-h').value = CONFIG.h;
        centerCanvas();
        resizeCanvas(CONFIG.w, CONFIG.h);
        requestAnimationFrame(animLoop);
        updateUI();
    };

    function centerCanvas() { view.x = (window.innerWidth - (CONFIG.w * view.scale)) / 2; view.y = (window.innerHeight - (CONFIG.h * view.scale)) / 2; updateTransform(); }

    function animLoop() {
        overlayCtx.clearRect(0, 0, CONFIG.w, CONFIG.h);

        if (state.tool === 'transform' && state.transformImg && state.transformRect) {
            const r = state.transformRect;
            overlayCtx.save();
            overlayCtx.drawImage(state.transformImg, r.x, r.y, r.w, r.h);
            overlayCtx.strokeStyle = '#e84393'; overlayCtx.lineWidth = 2/view.scale;
            overlayCtx.strokeRect(r.x, r.y, r.w, r.h);
            const hSz = 10/view.scale; overlayCtx.fillStyle = '#fff';
            overlayCtx.fillRect(r.x-hSz/2, r.y-hSz/2, hSz, hSz); overlayCtx.fillRect(r.x+r.w-hSz/2, r.y-hSz/2, hSz, hSz);
            overlayCtx.fillRect(r.x-hSz/2, r.y+r.h-hSz/2, hSz, hSz); overlayCtx.fillRect(r.x+r.w-hSz/2, r.y+r.h-hSz/2, hSz, hSz);
            overlayCtx.restore();
        }

        if (state.hasSelection && state.tool !== 'transform') {
            state.dashOffset = (state.dashOffset + 1) % 16;
            overlayCtx.save();
            overlayCtx.globalAlpha = 0.15;
            overlayCtx.drawImage(selCanvas, 0, 0);
            overlayCtx.globalCompositeOperation = 'source-in';
            overlayCtx.fillStyle = '#0984e3';
            overlayCtx.fillRect(0, 0, CONFIG.w, CONFIG.h);
            overlayCtx.globalCompositeOperation = 'source-over';
            overlayCtx.globalAlpha = 1.0;
            if (state.activeSelectionPath) {
                overlayCtx.lineWidth = 2 / view.scale;
                overlayCtx.strokeStyle = 'white'; overlayCtx.setLineDash([5, 5]); overlayCtx.lineDashOffset = -state.dashOffset;
                overlayCtx.stroke(state.activeSelectionPath);
                overlayCtx.strokeStyle = 'black'; overlayCtx.lineDashOffset = -state.dashOffset + 5;
                overlayCtx.stroke(state.activeSelectionPath);
            }
            overlayCtx.restore();
        }

        if (state.tool === 'lasso' && state.isDrawing) {
            overlayCtx.save();
            overlayCtx.lineWidth = 1 / view.scale; 
            overlayCtx.strokeStyle = state.lassoOp === 'sub' ? '#ff4757' : '#fff';
            overlayCtx.setLineDash([4,4]);
            overlayCtx.beginPath();
            const start = state.lassoStartPoint; const end = state.lassoEndPoint; 
            if (start) {
                if (state.lassoMode === 'rect' && end) overlayCtx.rect(start.x, start.y, end.x - start.x, end.y - start.y);
                else if (state.lassoMode === 'circ' && end) overlayCtx.arc(start.x, start.y, Math.hypot(end.x-start.x, end.y-start.y), 0, Math.PI*2);
                else if ((state.lassoMode === 'free' || state.lassoMode === 'poly') && state.lassoPoly.length > 0) {
                    overlayCtx.moveTo(state.lassoPoly[0].x, state.lassoPoly[0].y);
                    for(let i=1; i<state.lassoPoly.length; i++) overlayCtx.lineTo(state.lassoPoly[i].x, state.lassoPoly[i].y);
                    if (state.lassoMode === 'poly' && end) overlayCtx.lineTo(end.x, end.y);
                }
            }
            overlayCtx.stroke(); overlayCtx.strokeStyle = '#000'; overlayCtx.lineDashOffset = 4; overlayCtx.stroke();
            overlayCtx.restore();
        }

        if (state.tool === 'gradient' && state.gradDragStart && state.gradDragCurrent) {
            overlayCtx.save();
            overlayCtx.lineWidth = 2 / view.scale; overlayCtx.strokeStyle = 'white'; overlayCtx.shadowColor = 'black'; overlayCtx.shadowBlur = 3;
            overlayCtx.beginPath(); 
            const start = state.gradDragStart; const end = state.gradDragCurrent;
            if (state.gradType === 'radial') {
                const r = Math.hypot(end.x - start.x, end.y - start.y);
                overlayCtx.arc(start.x, start.y, r, 0, Math.PI * 2);
                overlayCtx.moveTo(start.x, start.y); overlayCtx.lineTo(end.x, end.y); 
            } else {
                overlayCtx.moveTo(start.x, start.y); overlayCtx.lineTo(end.x, end.y);
            }
            overlayCtx.stroke();
            overlayCtx.fillStyle = state.gradStartColor; overlayCtx.beginPath(); overlayCtx.arc(start.x, start.y, 5/view.scale, 0, Math.PI*2); overlayCtx.fill();
            overlayCtx.fillStyle = state.gradEndColor; overlayCtx.beginPath(); overlayCtx.arc(end.x, end.y, 5/view.scale, 0, Math.PI*2); overlayCtx.fill();
            overlayCtx.restore();
        }
        requestAnimationFrame(animLoop);
    }

    // --- TRANSFORM ---
    function initTransform() {
        let bounds = { x: 0, y: 0, w: CONFIG.w, h: CONFIG.h };
        if (state.hasSelection && state.selectionBounds) bounds = state.selectionBounds;
        if(bounds.w <= 0 || bounds.h <= 0) return;

        saveHistory();
        const dpr = window.devicePixelRatio || 1;
        const tempC = document.createElement('canvas'); tempC.width = bounds.w * dpr; tempC.height = bounds.h * dpr;
        const tCtx = tempC.getContext('2d');
        
        if (state.hasSelection) {
            tCtx.drawImage(layers[activeIdx].canvas, bounds.x*dpr, bounds.y*dpr, bounds.w*dpr, bounds.h*dpr, 0, 0, bounds.w*dpr, bounds.h*dpr);
            tCtx.globalCompositeOperation = 'destination-in';
            tCtx.drawImage(selCanvas, bounds.x, bounds.y, bounds.w, bounds.h, 0, 0, bounds.w*dpr, bounds.h*dpr);
            layers[activeIdx].ctx.save();
            layers[activeIdx].ctx.globalCompositeOperation = 'destination-out';
            layers[activeIdx].ctx.drawImage(selCanvas, 0, 0, CONFIG.w, CONFIG.h); 
            layers[activeIdx].ctx.restore();
        } else {
            tCtx.drawImage(layers[activeIdx].canvas, 0, 0);
            layers[activeIdx].ctx.clearRect(0,0,CONFIG.w, CONFIG.h);
        }
        state.transformImg = tempC; state.transformRect = { ...bounds };
    }

    function commitTransform() {
        if (!state.transformImg || !state.transformRect) return;
        const r = state.transformRect;
        layers[activeIdx].ctx.drawImage(state.transformImg, r.x, r.y, r.w, r.h);
        state.transformImg = null; state.transformRect = null;
        if(state.hasSelection) clearSelection();
        setTool('brush');
    }

    // --- SELECTION ---
    function finishLasso() {
        const path = new Path2D();
        const start = state.lassoStartPoint; const end = state.lassoEndPoint || start; 
        let minX = CONFIG.w, minY = CONFIG.h, maxX = 0, maxY = 0;
        const addPt = (x,y) => { if(x<minX)minX=x; if(x>maxX)maxX=x; if(y<minY)minY=y; if(y>maxY)maxY=y; };

        if (state.lassoMode === 'rect' && start) {
            path.rect(start.x, start.y, end.x - start.x, end.y - start.y);
            addPt(start.x, start.y); addPt(end.x, end.y);
        } else if (state.lassoMode === 'circ' && start) {
            const r = Math.hypot(end.x - start.x, end.y - start.y);
            path.arc(start.x, start.y, r, 0, Math.PI*2);
            addPt(start.x-r, start.y-r); addPt(start.x+r, start.y+r);
        } else if (state.lassoPoly.length > 1) {
            path.moveTo(state.lassoPoly[0].x, state.lassoPoly[0].y); addPt(state.lassoPoly[0].x, state.lassoPoly[0].y);
            for(let i=1; i<state.lassoPoly.length; i++) {
                path.lineTo(state.lassoPoly[i].x, state.lassoPoly[i].y);
                addPt(state.lassoPoly[i].x, state.lassoPoly[i].y);
            }
            path.closePath();
        } else return;

        state.selectionBounds = { x: minX, y: minY, w: maxX-minX, h: maxY-minY };
        selCtx.save();
        if (state.lassoOp === 'new') { selCtx.clearRect(0,0,CONFIG.w, CONFIG.h); selCtx.fillStyle = '#000000'; selCtx.fill(path); state.activeSelectionPath = path; }
        else if (state.lassoOp === 'add') { selCtx.globalCompositeOperation = 'source-over'; selCtx.fillStyle = '#000000'; selCtx.fill(path); if(state.activeSelectionPath) state.activeSelectionPath.addPath(path); else state.activeSelectionPath = path; }
        else if (state.lassoOp === 'sub') { selCtx.globalCompositeOperation = 'destination-out'; selCtx.fillStyle = '#000000'; selCtx.fill(path); }
        selCtx.restore();
        state.hasSelection = true; state.lassoPoly = []; state.lassoStartPoint = null; state.lassoEndPoint = null;
    }

    function clearSelection() { selCtx.clearRect(0,0,CONFIG.w, CONFIG.h); state.hasSelection = false; state.activeSelectionPath = null; state.lassoPoly = []; state.selectionBounds = null; }

    function saveImage() {
        const dpr = window.devicePixelRatio || 1;
        const c = document.createElement('canvas'); 
        c.width = CONFIG.w * dpr; 
        c.height = CONFIG.h * dpr;
        
        const ctx = c.getContext('2d'); 
        
        // Fill White BG
        ctx.fillStyle = 'white'; 
        ctx.fillRect(0, 0, c.width, c.height);
        
        layers.forEach(l => { 
            if(l.visible) {
                ctx.save();
                ctx.globalAlpha = l.opacity;
                ctx.globalCompositeOperation = l.blendMode === 'normal' ? 'source-over' : l.blendMode;
                ctx.drawImage(l.canvas, 0, 0);
                ctx.restore();
            } 
        });
        
        const a = document.createElement('a'); 
        a.download = 'art_highres.png'; 
        a.href = c.toDataURL('image/png'); 
        a.click();
    }

    // --- DRAWING ---
    function draw(p1, p2) {
        if (!layers[activeIdx]) return;
        const ctx = layers[activeIdx].ctx;
        if ((state.tool === 'blend') && !state.canBlend) return;
        const dist = Math.hypot(p2.x - p1.x, p2.y - p1.y);
        const angle = Math.atan2(p2.y - p1.y, p2.x - p1.x);
        
        let stepSize = state.size / 8; 
        if(state.brush === 'air_soft') stepSize = 1; 
        if(state.brush === 'rake') stepSize = 1;
        
        const steps = Math.ceil(dist / Math.max(0.25, stepSize));
        ctx.save();
        if (state.tool === 'eraser') ctx.globalCompositeOperation = 'destination-out';
        else if (layers[activeIdx].alphaLock) ctx.globalCompositeOperation = 'source-atop';
        else ctx.globalCompositeOperation = 'source-over';
        
        const isClipped = layers[activeIdx].clipped && activeIdx > 0 && state.tool !== 'eraser';
        let currentSize = state.size; if (state.usePressure) currentSize = Math.max(1, state.size * state.pressure);
        const dpr = window.devicePixelRatio || 1;
        
        for(let i=0; i<=steps; i++) {
            const t = steps===0 ? 0 : i/steps; const x = lerp(p1.x, p2.x, t); const y = lerp(p1.y, p2.y, t);
            scratchCanvas.width = currentSize * 2 * dpr; scratchCanvas.height = currentSize * 2 * dpr;
            scratchCtx.setTransform(1,0,0,1,0,0); scratchCtx.scale(dpr,dpr); scratchCtx.clearRect(0,0,currentSize*2,currentSize*2);
            scratchCtx.save(); scratchCtx.translate(currentSize, currentSize);
            if(state.brush !== 'round' && state.brush !== 'air_soft') scratchCtx.rotate(angle);
            scratchCtx.fillStyle = '#000';
            
            if(state.brush === 'block') { scratchCtx.fillRect(-currentSize/2, -currentSize/2, currentSize, currentSize); }
            else if (state.brush === 'round') { scratchCtx.beginPath(); scratchCtx.arc(0,0, currentSize/2, 0, Math.PI*2); scratchCtx.fill(); }
            
            // --- PERFECT SOFT BRUSH (ShadowBlur) ---
            else if (state.brush === 'air_soft') { 
                scratchCtx.shadowBlur = currentSize/2; 
                scratchCtx.shadowColor = 'black'; 
                scratchCtx.beginPath();
                scratchCtx.arc(0, 0, currentSize/4, 0, Math.PI*2); 
                scratchCtx.fill();
                scratchCtx.shadowBlur = 0; 
            }
            
            else if (state.brush === 'rake') { const bristleH = currentSize / BRISTLE_COUNT; for(let b=0; b<BRISTLE_COUNT; b++) { const bristle = bristles[b]; const yOffset = -currentSize/2 + (b * bristleH) + bristle.offset; const r = (bristleH * bristle.thickness) * 0.8; scratchCtx.beginPath(); scratchCtx.arc(0, yOffset, Math.max(0.5, r), 0, Math.PI*2); scratchCtx.fill(); } }
            
            else if (state.brush === 'air_grain') { 
                const density = Math.max(30, state.grain * 500); const maxRad = currentSize / 2; 
                for(let k=0; k<density; k++) { 
                    const angle = Math.random() * Math.PI * 2; 
                    const r = Math.sqrt(Math.random()) * maxRad; 
                    const rx = Math.cos(angle) * r; const ry = Math.sin(angle) * r; 
                    const sizeVar = Math.random() * 2 + 0.5; // Random Size variety
                    scratchCtx.beginPath(); scratchCtx.arc(rx, ry, sizeVar/2, 0, Math.PI*2); scratchCtx.fill();
                } 
            }
            scratchCtx.restore();

            // --- GLOBAL GRAIN (ALL BRUSHES) ---
            if (state.grain > 0 && state.brush !== 'air_grain') {
                scratchCtx.globalCompositeOperation = 'destination-out';
                const grainCount = Math.floor(state.grain * (currentSize * currentSize / 8));
                for(let g=0; g<grainCount; g++) {
                    const gx = (Math.random() - 0.5) * currentSize * 2;
                    const gy = (Math.random() - 0.5) * currentSize * 2;
                    const gSz = Math.random() * 2 + 0.5; // Random Grain Size
                    scratchCtx.beginPath(); scratchCtx.arc(gx, gy, gSz/2, 0, Math.PI*2); scratchCtx.fill();
                }
                scratchCtx.globalCompositeOperation = 'source-over';
            }

            scratchCtx.globalCompositeOperation = 'source-in';
            if (state.tool === 'mixer' && state.mixerBuffer) { scratchCtx.drawImage(state.mixerBuffer, 0, 0, currentSize*2, currentSize*2); }
            else { prepBrushColor(ctx, x, y); scratchCtx.fillStyle = `rgb(${brushLoad.r},${brushLoad.g},${brushLoad.b})`; scratchCtx.fillRect(0,0, currentSize*2, currentSize*2); }
            if (state.hasSelection) { scratchCtx.globalCompositeOperation = 'destination-in'; scratchCtx.drawImage(selCanvas, x-currentSize, y-currentSize, currentSize*2, currentSize*2, 0, 0, currentSize*2, currentSize*2); }
            
            let flow = state.opacity;
            if (state.brush === 'air_soft') flow = state.opacity * 0.1; // Lower flow for shadow buildup
            else if (state.tool === 'blend') flow = 0.2;
            
            ctx.globalAlpha = flow;

            if(isClipped) { const tempC = document.createElement('canvas'); tempC.width = currentSize*2*dpr; tempC.height=currentSize*2*dpr; const tCtx = tempC.getContext('2d'); tCtx.scale(dpr,dpr); tCtx.drawImage(layers[activeIdx-1].canvas, (x-currentSize)*dpr, (y-currentSize)*dpr, currentSize*2*dpr, currentSize*2*dpr, 0, 0, currentSize*2, currentSize*2); tCtx.globalCompositeOperation = 'source-in'; tCtx.drawImage(scratchCanvas, 0, 0, currentSize*2, currentSize*2); ctx.drawImage(tempC, x-currentSize, y-currentSize, currentSize*2, currentSize*2); }
            else { ctx.drawImage(scratchCanvas, x-currentSize, y-currentSize, currentSize*2, currentSize*2); }
        }
        ctx.restore();
    }

    function pickColorAt(ctx, x, y) { const dpr = window.devicePixelRatio || 1; const p = ctx.getImageData(Math.floor(x * dpr), Math.floor(y * dpr), 1, 1).data; return p[3] < 10 ? null : { r: p[0], g: p[1], b: p[2] }; }
    
    function pickGlobalColor(x, y) {
        const dpr = window.devicePixelRatio || 1;
        for (let i = layers.length - 1; i >= 0; i--) {
            const l = layers[i];
            if (!l.visible || l.opacity === 0) continue;
            const p = l.ctx.getImageData(Math.floor(x*dpr), Math.floor(y*dpr), 1, 1).data;
            if (p[3] > 0) return { r: p[0], g: p[1], b: p[2] };
        }
        return { r: 255, g: 255, b: 255 }; 
    }

    function sampleMixer(x, y) { const dpr = window.devicePixelRatio || 1; const s = state.size; const data = layers[activeIdx].ctx.getImageData(Math.floor((x-s/2)*dpr), Math.floor((y-s/2)*dpr), s*dpr, s*dpr); const c = document.createElement('canvas'); c.width = s; c.height = s; const t = c.getContext('2d'); const temp = document.createElement('canvas'); temp.width = s*dpr; temp.height = s*dpr; temp.getContext('2d').putImageData(data, 0, 0); t.drawImage(temp, 0, 0, s*dpr, s*dpr, 0, 0, s, s); state.mixerBuffer = c; }
    function hexToRgb(hex) { const v = parseInt(hex.slice(1), 16); return { r: (v >> 16) & 255, g: (v >> 8) & 255, b: v & 255 }; }
    function getGradientColor(hex, alpha) { const c = hexToRgb(hex); return `rgba(${c.r},${c.g},${c.b},${alpha})`; }
    function lerp(a, b, t) { return a + (b - a) * t; }
    function prepBrushColor(ctx, x, y) { if(state.tool === 'blend') { const bg = pickColorAt(ctx, x, y); if(bg) { brushLoad.r = lerp(brushLoad.r, bg.r, state.mix); brushLoad.g = lerp(brushLoad.g, bg.g, state.mix); brushLoad.b = lerp(brushLoad.b, bg.b, state.mix); } } else if(state.jitter > 0) brushLoad = getJitteredColor(hexToRgb(state.color), state.jitter); else { const rgb = hexToRgb(state.color); brushLoad = {r:rgb.r, g:rgb.g, b:rgb.b}; } }
    function initPhysics(startColor) { bristles = []; for(let i=0; i<BRISTLE_COUNT; i++) { const c = (state.tool === 'brush') ? getJitteredColor(startColor, state.jitter) : startColor; const thick = Math.random() * 0.6 + 0.4; const off = (Math.random() - 0.5) * (state.size / 5); bristles.push({ r: c.r, g: c.g, b: c.b, thickness: thick, offset: off }); } const c = (state.tool === 'brush') ? getJitteredColor(startColor, state.jitter) : startColor; brushLoad = { r: c.r, g: c.g, b: c.b }; }
    function getJitteredColor(base, amount) { if (amount <= 0) return base; let r = base.r, g = base.g, b = base.b; r = Math.min(255, Math.max(0, r + (Math.random()-0.5)*amount*2)); g = Math.min(255, Math.max(0, g + (Math.random()-0.5)*amount*2)); b = Math.min(255, Math.max(0, b + (Math.random()-0.5)*amount*2)); return {r, g, b}; }
    function applyGradient() { if(!state.gradDragStart || !state.gradDragCurrent) return; saveHistory(); const ctx = layers[activeIdx].ctx; ctx.save(); 
        const start = state.gradDragStart; const end = state.gradDragCurrent;
        let g;
        if(state.gradType === 'radial') {
            const r = Math.hypot(end.x - start.x, end.y - start.y);
            g = ctx.createRadialGradient(start.x, start.y, 0, start.x, start.y, r);
        } else {
            g = ctx.createLinearGradient(start.x, start.y, end.x, end.y);
        }
        g.addColorStop(0, getGradientColor(state.gradStartColor, state.gradStartOpacity)); g.addColorStop(1, getGradientColor(state.gradEndColor, state.gradEndOpacity)); 
        if (state.hasSelection) { const temp = document.createElement('canvas'); temp.width = CONFIG.w; temp.height = CONFIG.h; const tCtx = temp.getContext('2d'); tCtx.fillStyle = g; tCtx.fillRect(0,0,CONFIG.w, CONFIG.h); tCtx.globalCompositeOperation = 'destination-in'; tCtx.drawImage(selCanvas, 0, 0); if(layers[activeIdx].alphaLock) ctx.globalCompositeOperation = 'source-atop'; ctx.drawImage(temp, 0, 0); } 
        else { if(layers[activeIdx].alphaLock) ctx.globalCompositeOperation = 'source-atop'; ctx.fillStyle = g; ctx.fillRect(0,0,CONFIG.w, CONFIG.h); } 
        ctx.restore(); state.gradDragStart = null; 
    }
    function rotateCanvas() { const w = parseInt(document.getElementById('cnv-w').value); const h = parseInt(document.getElementById('cnv-h').value); document.getElementById('cnv-w').value = h; document.getElementById('cnv-h').value = w; applyCanvasResize(); }
    function applyCanvasResize() { const w = parseInt(document.getElementById('cnv-w').value); const h = parseInt(document.getElementById('cnv-h').value); if(!w || !h) return; resizeCanvas(w, h); }
    function resizeCanvas(w, h) { const oldData = layers.map(l => ({ img: l.ctx.getImageData(0,0,l.canvas.width, l.canvas.height), props: { ...l } })); CONFIG.w = w; CONFIG.h = h; container.style.width = w+'px'; container.style.height = h+'px'; overlayCanvas.width = w; overlayCanvas.height = h; overlayCanvas.style.width = w+'px'; overlayCanvas.style.height = h+'px'; selCanvas.width = w; selCanvas.height = h; antsCanvas.width = w; antsCanvas.height = h; state.hasSelection = false; state.activeSelectionPath = null; document.getElementById('layerList').innerHTML = ''; document.querySelectorAll('.layer-canvas').forEach(el => el.remove()); layers = []; layerCounter = 0; if(oldData.length === 0) addLayer(); else { oldData.forEach(old => { const l = createLayerDOM(old.props.name); l.ctx.putImageData(old.img, 0, 0); l.visible = old.props.visible; l.canvas.style.display = l.visible?'block':'none'; l.blendMode = old.props.blendMode; l.alphaLock = old.props.alphaLock; l.clipped = old.props.clipped; l.opacity = old.props.opacity; l.canvas.style.opacity = l.opacity; l.canvas.style.mixBlendMode = old.props.blendMode; }); activeIdx = Math.max(0, layers.length - 1); renderLayerUI(); } updateTransform(); }
    function addLayer() { layerCounter++; createLayerDOM(`Layer ${layerCounter}`); activeIdx = layers.length - 1; renderLayerUI(); }
    function createLayerDOM(name) { const dpr = window.devicePixelRatio || 1; const c = document.createElement('canvas'); c.className = 'layer-canvas'; c.width = CONFIG.w*dpr; c.height = CONFIG.h*dpr; c.style.width = CONFIG.w+'px'; c.style.height = CONFIG.h+'px'; container.insertBefore(c, selCanvas); const ctx = c.getContext('2d', {willReadFrequently:true}); ctx.scale(dpr, dpr); const lObj = { id: Math.random(), canvas: c, ctx: ctx, name: name, visible: true, blendMode: 'normal', alphaLock: false, clipped: false, opacity: 1.0 }; c.style.opacity = 1.0; layers.push(lObj); return lObj; }
    function renderLayerUI() { const list = document.getElementById('layerList'); list.innerHTML = ''; layers.forEach((l, i) => { const div = document.createElement('div'); div.className = `l-item ${i === activeIdx ? 'active' : ''}`; div.innerHTML = `<div style="display:flex; gap:8px;"><div class="l-vis ${l.visible?'on':''}" onclick="toggleVis(event, ${i})"></div> ${l.name}</div>`; div.onclick = () => { activeIdx = i; renderLayerUI(); updateLayerControls(); }; list.appendChild(div); }); updateLayerControls(); }
    function updateLayerControls() { if(!layers[activeIdx]) return; const l = layers[activeIdx]; document.getElementById('blendModeSel').value = l.blendMode; document.getElementById('alphaLockChk').checked = l.alphaLock; document.getElementById('clipMaskChk').checked = l.clipped; document.getElementById('layerOpacity').value = Math.round(l.opacity * 100); document.getElementById('val-layer-op').innerText = Math.round(l.opacity * 100); }
    function setLayerProp(k, v) { if(!layers[activeIdx]) return; layers[activeIdx][k] = v; if(k === 'blendMode') layers[activeIdx].canvas.style.mixBlendMode = v; if(k === 'opacity') layers[activeIdx].canvas.style.opacity = v; renderLayerUI(); }
    function toggleVis(e, i) { e.stopPropagation(); layers[i].visible = !layers[i].visible; layers[i].canvas.style.display = layers[i].visible ? 'block' : 'none'; renderLayerUI(); }
    function deleteLayer() { if(layers.length <= 1) { layers[0].ctx.clearRect(0,0,CONFIG.w, CONFIG.h); return; } layers[activeIdx].canvas.remove(); layers.splice(activeIdx, 1); activeIdx = Math.max(0, activeIdx - 1); renderLayerUI(); }
    function clearLayer() { saveHistory(); layers[activeIdx].ctx.clearRect(0,0,CONFIG.w, CONFIG.h); }
    function saveHistory() { if(historyStack.length > 10) historyStack.shift(); historyStack.push({ id: layers[activeIdx].id, data: layers[activeIdx].ctx.getImageData(0,0,CONFIG.w*window.devicePixelRatio, CONFIG.h*window.devicePixelRatio) }); redoStack = []; }
    function undo() { if(!historyStack.length) return; const state = historyStack.pop(); redoStack.push({ id: state.id, data: layers.find(l=>l.id===state.id).ctx.getImageData(0,0,CONFIG.w*window.devicePixelRatio, CONFIG.h*window.devicePixelRatio) }); const l = layers.find(l => l.id === state.id); if(l) l.ctx.putImageData(state.data, 0, 0); }
    function redo() { if(!redoStack.length) return; const state = redoStack.pop(); historyStack.push({ id: state.id, data: layers.find(l=>l.id===state.id).ctx.getImageData(0,0,CONFIG.w*window.devicePixelRatio, CONFIG.h*window.devicePixelRatio) }); const l = layers.find(l => l.id === state.id); if(l) l.ctx.putImageData(state.data, 0, 0); }
    
    function setTool(t) {
        state.tool = t; 
        if(t !== 'brush') document.querySelectorAll('#brush-controls .btn').forEach(b=>b.classList.remove('active-brush'));
        if(t === 'transform') initTransform(); else { if(state.transformImg) commitTransform(); } 
        
        document.querySelectorAll('.t-btn').forEach(b => b.classList.remove('active', 'active-blue', 'active-purp', 'active-green', 'active-mix', 'active-move'));
        const el = document.getElementById('t-'+t);
        if(el) { if(t==='lasso'||t==='canvas') el.classList.add('active-blue'); else if(t==='gradient') el.classList.add('active-purp'); else if(t==='blend') el.classList.add('active-green'); else if(t==='mixer') el.classList.add('active-mix'); else if(t==='transform') el.classList.add('active-move'); else el.classList.add('active'); }
        
        document.getElementById('brush-controls').style.display = (t==='brush'||t==='eraser'||t==='blend'||t==='mixer')?'block':'none';
        document.getElementById('lasso-controls').style.display = t==='lasso'?'block':'none';
        document.getElementById('grad-controls').style.display = t==='gradient'?'block':'none';
        document.getElementById('canvas-controls').style.display = t==='canvas'?'block':'none';
        document.getElementById('transform-controls').style.display = t==='transform'?'block':'none';
        
        if(t==='brush' || t==='eraser' || t==='blend' || t==='mixer') setBrush(state.brush);
    }
    
    function setBrush(b) { state.brush = b; document.querySelectorAll('#brush-controls .btn').forEach(btn => btn.classList.remove('active-brush')); document.getElementById('b-'+b).classList.add('active-brush'); }
    function setLassoShape(m) { state.lassoMode = m; state.lassoPoly = []; document.querySelectorAll('#lasso-controls .btn-grid .btn').forEach(b => b.classList.remove('active-brush')); document.getElementById('l-'+m).classList.add('active-brush'); }
    function setLassoOp(op) { state.lassoOp = op; document.querySelectorAll('#lasso-controls .btn-grid-3 .btn').forEach(b=>b.classList.remove('active-opt')); document.getElementById('op-'+op).classList.add('active-opt'); }
    
    function decoupleGradient() { state.gradDecoupled = true; } 
    function setActiveGradStop(stop) {
        state.activeGradStop = stop;
        document.querySelectorAll('input[type="color"]').forEach(el => el.classList.remove('active-stop'));
        document.getElementById(stop === 'start' ? 'gradStart' : 'gradEnd').classList.add('active-stop');
        const hex = stop === 'start' ? state.gradStartColor : state.gradEndColor;
        state.color = hex; updateSlidersFromColor(hex);
    }

    function pickColorUI(p) { 
        const c = pickGlobalColor(p.x, p.y); 
        const hex = "#" + ((1 << 24) + (c.r << 16) + (c.g << 8) + c.b).toString(16).slice(1); 
        if(state.tool === 'gradient') {
            if(state.activeGradStop === 'start') {
                state.gradStartColor = hex; document.getElementById('gradStart').value = hex;
                if(!state.gradDecoupled) { state.gradEndColor = hex; document.getElementById('gradEnd').value = hex; }
            } else {
                state.gradEndColor = hex; document.getElementById('gradEnd').value = hex;
            }
            updateSlidersFromColor(hex);
        } else { state.color = hex; updateSlidersFromColor(state.color); }
    }

    function showFeedback(x, y) { const fb = document.getElementById('sample-feedback'); fb.style.left = x+'px'; fb.style.top = y+'px'; fb.classList.add('active'); setTimeout(()=>fb.classList.remove('active'), 300); }
    document.getElementById('sl-r').oninput = updateColor; document.getElementById('sl-g').oninput = updateColor; document.getElementById('sl-b').oninput = updateColor;
    
    function updateColor() { 
        const r = parseInt(document.getElementById('sl-r').value); 
        const g = parseInt(document.getElementById('sl-g').value); 
        const b = parseInt(document.getElementById('sl-b').value); 
        const hex = "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1); 
        document.getElementById('rgbPreview').style.background = hex;
        if(state.tool === 'gradient') {
            if(state.activeGradStop === 'start') {
                state.gradStartColor = hex; document.getElementById('gradStart').value = hex;
                 if(!state.gradDecoupled) { state.gradEndColor = hex; document.getElementById('gradEnd').value = hex; }
            } else { state.gradEndColor = hex; document.getElementById('gradEnd').value = hex; }
        } else { state.color = hex; }
    }
    
    function updateSlidersFromColor(hex) { const rgb = hexToRgb(hex); document.getElementById('sl-r').value = rgb.r; document.getElementById('sl-g').value = rgb.g; document.getElementById('sl-b').value = rgb.b; document.getElementById('rgbPreview').style.background = hex; }
    document.getElementById('sl-size').oninput = e => { state.size = +e.target.value; document.getElementById('val-size').innerText = state.size; };
    document.getElementById('sl-op').oninput = e => { state.opacity = e.target.value / 100; document.getElementById('val-op').innerText = e.target.value; };
    document.getElementById('sl-mix').oninput = e => { state.mix = +e.target.value/100; document.getElementById('val-mix').innerText = e.target.value; };
    document.getElementById('sl-jitter').oninput = e => { state.jitter = +e.target.value; document.getElementById('val-jitter').innerText = state.jitter; };
    document.getElementById('sl-grain').oninput = e => { state.grain = +e.target.value/100; document.getElementById('val-grain').innerText = e.target.value; };
    document.getElementById('gradStart').oninput = e => state.gradStartColor = e.target.value; 
    document.getElementById('gradEnd').oninput = e => { state.gradEndColor = e.target.value; state.gradDecoupled = true; }; 
    document.getElementById('gradStartAlpha').oninput = e => state.gradStartOpacity = +e.target.value/100; document.getElementById('gradEndAlpha').oninput = e => state.gradEndOpacity = +e.target.value/100;
    document.getElementById('layerOpacity').oninput = e => { const val = e.target.value / 100; setLayerProp('opacity', val); document.getElementById('val-layer-op').innerText = e.target.value; };

    function updateTransform() { const str = `translate(${view.x}px, ${view.y}px) scale(${view.scale})`; container.style.transform = str; updateCursor(null); }
    function getPos(e) { const rect = container.getBoundingClientRect(); return { x: (e.clientX - rect.left) / view.scale, y: (e.clientY - rect.top) / view.scale }; }
    
    window.addEventListener('pointerdown', e => {
        if(e.target.closest('.panel') || e.target.closest('.top-bar')) return;
        if (isSpace || isZ) { dragStart = { x: e.clientX, y: e.clientY }; return; }
        const p = getPos(e);
        if(state.tool === 'transform' && state.transformRect) {
            const r = state.transformRect; const hSz = 10/view.scale;
            if (Math.hypot(p.x - r.x, p.y - r.y) < hSz) state.transformHandle = 'TL';
            else if (Math.hypot(p.x - (r.x+r.w), p.y - r.y) < hSz) state.transformHandle = 'TR';
            else if (Math.hypot(p.x - r.x, p.y - (r.y+r.h)) < hSz) state.transformHandle = 'BL';
            else if (Math.hypot(p.x - (r.x+r.w), p.y - (r.y+r.h)) < hSz) state.transformHandle = 'BR';
            else if (p.x > r.x && p.x < r.x + r.w && p.y > r.y && p.y < r.y + r.h) state.transformHandle = 'MOVE';
            if(state.transformHandle) { state.isDrawing = true; state.lastPos = p; return; }
        }
        if(e.altKey) { if(state.tool === 'lasso') setLassoOp('sub'); else if(state.tool === 'mixer') sampleMixer(p.x, p.y); else pickColorUI(p); showFeedback(e.clientX, e.clientY); return; }
        state.isDrawing = true;
        if(e.pressure > 0 && e.pressure !== 0.5) state.pressure = e.pressure; else state.pressure = 1.0;
        if (state.tool === 'mixer' && !state.mixerBuffer) sampleMixer(p.x, p.y);
        if (state.tool === 'gradient') { state.gradDragStart = p; state.gradDragCurrent = p; }
        if (state.tool === 'brush' || state.tool === 'eraser' || state.tool === 'blend' || state.tool === 'mixer') {
            state.canBlend = true; if(state.tool === 'blend' && !pickColorAt(layers[activeIdx].ctx, p.x, p.y)) state.canBlend = false;
            saveHistory(); initPhysics(hexToRgb(state.color)); draw(p, p); state.lastPos = p;
        } else if (state.tool === 'lasso') {
            state.lassoStartPoint = p; state.lassoEndPoint = p;
            if (state.lassoMode === 'poly') { if (state.lassoPoly.length === 0) state.lassoPoly.push(p); } else { state.lassoPoly = [p]; }
        }
    });

    window.addEventListener('pointermove', e => {
        updateCursor(e);
        if (dragStart) {
            const dx = e.clientX - dragStart.x, dy = e.clientY - dragStart.y;
            if (isSpace) { view.x += dx; view.y += dy; } else if (isZ) { view.scale = Math.min(Math.max(view.scale * (1 + dx * 0.005), 0.05), 5); }
            updateTransform(); dragStart = { x: e.clientX, y: e.clientY }; return;
        }
        const p = getPos(e);
        if(state.tool === 'transform' && state.isDrawing && state.transformRect) {
            const dx = p.x - state.lastPos.x; const dy = p.y - state.lastPos.y;
            const r = state.transformRect;
            if(state.transformHandle === 'MOVE') { r.x += dx; r.y += dy; } 
            else {
                let ratio = r.w / r.h;
                if(state.transformHandle === 'BR') { r.w += dx; r.h += dy; if(e.shiftKey) r.h = r.w / ratio; } 
                else if (state.transformHandle === 'BL') { r.x += dx; r.w -= dx; r.h += dy; if(e.shiftKey) { r.h = r.w / ratio; } } 
                else if (state.transformHandle === 'TR') { r.y += dy; r.h -= dy; r.w += dx; if(e.shiftKey) { r.w = r.h * ratio; } } 
                else if (state.transformHandle === 'TL') { r.x += dx; r.w -= dx; r.y += dy; r.h -= dy; if(e.shiftKey) { r.w = r.h * ratio; } }
            }
            state.lastPos = p; return;
        }
        if (!state.isDrawing && state.tool !== 'lasso') return;
        if(e.pressure > 0 && e.pressure !== 0.5) state.pressure = e.pressure;
        if (state.tool === 'gradient') state.gradDragCurrent = p;
        else if (state.tool === 'lasso') { state.lassoEndPoint = p; if (state.lassoMode === 'free' && state.isDrawing) state.lassoPoly.push(p); else if(state.lassoMode==='poly') state.gradDragCurrent = p; }
        else if (state.isDrawing && state.lastPos) { draw(state.lastPos, p); state.lastPos = p; }
    });

    window.addEventListener('pointerup', (e) => {
        dragStart = null;
        const p = getPos(e);
        state.lassoEndPoint = p;
        if (state.tool === 'transform') { state.isDrawing = false; state.transformHandle = null; return; }
        if (state.tool === 'lasso' && state.lassoMode === 'poly' && state.isDrawing) { state.lassoPoly.push(p); state.isDrawing = false; return; }
        if (state.isDrawing) {
            state.isDrawing = false; state.lastPos = null;
            if (state.tool === 'lasso') finishLasso();
            if (state.tool === 'gradient') applyGradient();
        }
        if(e.altKey && state.tool === 'lasso') setLassoOp('add');
        state.gradDragStart = null;
    });

    window.addEventListener('keydown', e => {
        if (e.target.tagName === 'INPUT') return;
        const k = e.key.toLowerCase();
        if(k === ' ' && !isSpace) { isSpace = true; document.body.classList.add('grabbing'); }
        if(k === 'z' && !e.ctrlKey && !e.metaKey && !isZ) { isZ = true; document.body.classList.add('zooming'); }
        if ((e.ctrlKey || e.metaKey) && k === 'z') { e.preventDefault(); e.shiftKey ? redo() : undo(); return; }
        if ((e.ctrlKey || e.metaKey) && k === 'y') { e.preventDefault(); redo(); return; }
        if(k === 'b') setTool('brush'); if(k === 'l') setTool('lasso'); if(k === 'g') setTool('gradient'); if(k === 'm') setTool('mixer'); if(k === 'e') setTool('eraser'); if(k === 'd') clearSelection();
        if(k === 't') setTool('transform');
        if(k === 'enter') { if(state.tool==='lasso') finishLasso(); if(state.tool==='transform') commitTransform(); }
        if(k === 'alt') { if(state.tool==='lasso') setLassoOp('sub'); }
        if(k === '[') { state.size = Math.max(2, state.size - 5); document.getElementById('sl-size').value = state.size; }
        if(k === ']') { state.size = Math.min(300, state.size + 5); document.getElementById('sl-size').value = state.size; }
    });
    window.addEventListener('keyup', e => { if(e.key === ' ') { isSpace = false; document.body.classList.remove('grabbing'); } if(e.key.toLowerCase() === 'z') { isZ = false; document.body.classList.remove('zooming'); } if(e.key === 'Alt') { if(state.tool==='lasso') setLassoOp('add'); } });
    window.addEventListener('wheel', e => { if(e.ctrlKey) return; const z = e.deltaY > 0 ? 0.9 : 1.1; view.scale = Math.min(Math.max(view.scale * z, 0.05), 5); updateTransform(); });
    function updateCursor(e) { if(!e) return; cursor.style.left = e.clientX+'px'; cursor.style.top = e.clientY+'px'; const s = state.size * view.scale; cursor.style.width = s+'px'; cursor.style.height = s+'px'; cursor.style.borderRadius = (state.tool==='lasso'||state.tool==='gradient')?'0':'50%'; cursor.style.display = (isSpace||isZ) ? 'none' : 'block'; }
</script>
</body>
</html>